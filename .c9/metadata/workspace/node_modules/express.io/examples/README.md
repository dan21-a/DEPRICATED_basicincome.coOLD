{"changed":false,"filter":false,"title":"README.md","tooltip":"/node_modules/express.io/examples/README.md","value":"# Examples\n\n__All of these examples work__.  I repeat, __all of these examples work__.  Almost every example will work if copy and pasted.  These are working examples.  Just make sure you have `node` and `express.io` installed. :)\n\nYou can also run them straight out of the repository without copy-pasting, if you do the following.\n\n```bash\ngit clone git://github.com/techpines/express.io\ncd express.io/examples\nnpm install\n```\n\nThen `cd` into an example directory and run:\n\n```bash\nnode app.js\n```\n\n## Simple HTTP + IO Setup\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/http-io)\n\nThis is the canonical __express.io__ example.  It does nothing, except set up \nan http server and an io server together on the same port.\n\nWhen you run this example, the server should start.\n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// build realtime-web app\n\napp.listen(7076)\n```\n\n## Simple HTTPS + IO Setup\n\n__This is a copy-paste example, if key and cert files present.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/https-io)\n\nThis is the same as the HTTP example, but for HTTPS.  You have to pass the key and cert contents as an option.\n\nWhen you run this example, the server should start. \n\n#### Server (app.js)\n\n```js\nfs = require('fs')\noptions = {\n    key: fs.readFileSync('./key'), \n    cert: fs.readFileSync('./cert')\n} \n\napp = require('express.io')()\napp.https(options).io()\n\n// build realtime-web app\n\napp.listen(7076)\n```\n\n## Routing\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/routing)\n\nExpress.io comes with a simple io routing system.  Use `app.io.route` by providing a `route` and a `callback`.  The `callback` receives a [SocketRequest](https://github.com/techpines/express.io/tree/master/lib#socketrequest) object.\n\nThe philosophy behind the routing system is that it should be simple, flexible, and high performance.\n\nWhen you run this example, go to your browser on `localhost:7076`, and you should see an alert message pop up, that is triggered by the io route.\n\n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// Setup the ready route, and emit talk event.\napp.io.route('ready', function(req) {\n    req.io.emit('talk', {\n        message: 'io event from an io route on the server'\n    })\n})\n\n// Send the client html.\napp.get('/', function(req, res) {\n    res.sendfile(__dirname + '/client.html')\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\nio = io.connect()\n\n// Emit ready event.\nio.emit('ready') \n\n// Listen for the talk event.\nio.on('talk', function(data) {\n    alert(data.message)\n})  \n\n</script>\n```\n\n## Route Forwarding\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/route-forwarding)\n\nThe \"middleware\" style of routing is not a very good fit for io requests.  A typical io request does not need a response, so instead of \"middleware\", __express.io__ offers a robust system based on __route forwarding__.  Route forwarding can allow for a variety of rich, complex realtime interactions.\n\nTo forward a request, you use `req.io.route(route)`.\n\nIn this example, a route is a passed from an initial web request through two io routes, until finally back to the user.  If you go to `localhost:7076` you should see a simple json request returned.\n\n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// Initial web request.\napp.get('/', function(req, res) {\n    // Forward to an io route.\n    req.io.route('hello')\n})\n\n// Forward io route to another io route.\napp.io.route('hello', function(req) {\n    req.io.route('hello-again')\n})\n\n// Sends response from io route.\napp.io.route('hello-again', function(req) {\n    req.io.respond({hello: 'from io route'})\n})\n\napp.listen(7076)\n```\n\n__Note__: When you forward http requests to io routes, `req.io.respond(data)` will call `res.json(data)` on the actual http request.  This makes sense because http routes require a response, and the `respond` method is supposed to be a response for the given request.\n\nAlso, depending on the sophistication needed between a socket request and a web request, you might consider writing your own custom middleware layer and overriding `req.io.route` for your web requests.\n\n## Broadcasting\n\n__This is a copy-paste example__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/broadcasting)\n\nYou can easily broadcast messages to all your connected io clients.  There are two primary ways to broadcast a message using __express.io__:\n\n* `app.io.broadcast(event, data)` - Will send the `event` and `data` to all connected clients.\n* `req.io.broadcast(event, data)` - Will send the `event` and `data` to all connected clients except the client associated with the request.\n\nFor this example, pop open two browser windows to `localhost:7076`, then click refresh about five or six times on the second window, while watching what happens in the first window.\n\n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// Broadcast the new visitor event on ready route.\napp.io.route('ready', function(req) {\n    req.io.broadcast('new visitor')\n})\n\n// Send client html.\napp.get('/', function(req, res) {\n    res.sendfile(__dirname + '/client.html')\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\nio = io.connect()\n\n// Send the ready event.\nio.emit('ready')\n\n// Listen for the new visitor event.\nio.on('new visitor', function() {\n    $('body').append('<p>New visitor, hooray! ' + new Date().toString() +'</p>')\n})\n</script>\n```\n\n## Sessions\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/sessions)\n\nIn __express.io__, sessions are shared between web requests and io requests.  This makes it a breeze to share a little state or perform authentication.  You setup your sessions exactly as you would with express, and all the magic is handled for you!\n\nFor this example, go to `localhost:7076`, and you will be prompted by a few questions, and the server will prove the sessions are working.\n\n#### Server (app.js)\n\n```js\nexpress = require('express.io')\napp = express().http().io()\n\n// Setup your sessions, just like normal.\napp.use(express.cookieParser())\napp.use(express.session({secret: 'monkey'}))\n\n// Session is automatically setup on initial request.\napp.get('/', function(req, res) {\n    req.session.loginDate = new Date().toString()\n    res.sendfile(__dirname + '/client.html')\n})\n\n// Setup a route for the ready event, and add session data.\napp.io.route('ready', function(req) {\n    req.session.name = req.data\n    req.session.save(function() {\n        req.io.emit('get-feelings')\n    })\n})\n\n// Send back the session data.\napp.io.route('send-feelings', function(req) {\n    req.session.feelings = req.data\n    req.session.save(function() {\n        req.io.emit('session', req.session)\n    })\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n  var socket = io.connect();\n\n  // Emit ready event.\n  socket.emit('ready', prompt('What is your name?'))\n\n  // Listen for get-feelings event.\n  socket.on('get-feelings', function () {\n      socket.emit('send-feelings', prompt('How do you feel?'));\n  })\n\n  // Listen for session event.\n  socket.on('session', function(data) {\n      message = 'Hey ' + data.name + '!\\n\\n' \n      message += 'Server says you feel '+ data.feelings + '\\n'\n      message += 'I know these things because sessions work!\\n\\n'\n      message += 'Also, you joined ' + data.loginDate + '\\n'\n      alert(message)\n  })\n</script>\n```\n\n__Note__: You need to save the session explicitly for io requests, because there is no guarantee of a response, unlike a normal http request.\n\n## Rooms\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/rooms)\n\nSometimes you will want to group your io clients together into rooms.  With __express.io__ this is a breeze!  Here are the commands for dealing with rooms:\n\n* `req.io.join(room)` - The client for the request joins `room`.\n* `req.io.leave(room)` - The client for the request leaves `room`.\n* `req.io.room(room).broadcast(event, data)` - Broadcast to all client in the room except for the current one.\n* `app.io.room(room).broadcast(event, data)` - Broadcast to all clients in the room.\n\nFor this example, open two browser windows on `localhost:7076`.  You will be prompted to give a room name.  Enter the same room name for each browser, then check back with the first window to see the result.  \n\nAlso, try a third window with a different room name, and see your other windows miss the broadcast.\n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// Setup the ready route, join room and broadcast to room.\napp.io.route('ready', function(req) {\n    req.io.join(req.data)\n    req.io.room(req.data).broadcast('announce', {\n        message: 'New client in the ' + req.data + ' room. '\n    })\n})\n\n// Send the client html.\napp.get('/', function(req, res) {\n    res.sendfile(__dirname + '/client.html')\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\nio = io.connect()\nroom = prompt('type a room name')\n\n// Emit ready event with room name.\nio.emit('ready', room)\n\n// Listen for the announce event.\nio.on('announce', function(data) {\n    $('body').append('<p>'+data.message+ new Date().toString()+'</p>')\n})\n\n</script>\n```\n\n## Acknowledgements\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/acknowledgements)\n\nSometimes you need confirmation or acknowledgement from the server for an io request.  To respond from the server you need to call  `req.io.respond(data)`.\n\nFor this example, go to `localhost:7076` and you should get a pop-up from the acknowledgement. \n\n#### Server (app.js)\n\n```js\napp = require('express.io')()\napp.http().io()\n\n// Setup the ready route.\napp.io.route('ready', function(req) {\n    req.io.respond({\n        success: 'here is your acknowledegment for the ready event'\n    })\n})\n\napp.get('/', function(req, res) {\n    res.sendfile(__dirname + '/client.html')\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\nio = io.connect()\n\n// Emit ready event, and wait for acknowledgement.\nio.emit('ready', {hey: 'server'}, function(data) {\n    alert(data.success)\n})\n</script>\n```\n\nThis might lead some people to wonder, when is it best to send an acknowledgement vs just emitting an event to the client.  It actually doesn't matter, it's more of a code clarity thing.  Events are more flexible, because they can be triggered in a number of different ways, whereas the acknowledgement is a straight response.\n\nIn a way, the acknowledgements are a little more old-fashioned, pushing you towards the \"every request has a response\" mentality of traditional http.  Sometimes this is good, other times it's not.  Use common sense and just be consistent with whatever approach you take, and you should be fine.\n\n## Realtime Canvas\n\n__This is a copy-paste example.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/realtime-canvas)\n\nThis is a realtime canvas example.  It's really cool, and it works right of the box, so give it a try!\n\nOpen two browser windows on `localhost:7076`, then click and drag to draw in the first browser window, and you can see it draw in the second browser!\n\n#### Server (app.js)\n\n```js\nexpress = require('express.io')\napp = express().http().io()\n\n// Broadcast all draw clicks.\napp.io.route('drawClick', function(req) {\n    req.io.broadcast('draw', req.data)\n})\n\n// Send client html.\napp.get('/', function(req, res) {\n    res.sendfile(__dirname + '/client.html')\n})\n\napp.listen(7076)\n```\n\n#### Client (client.html)\n\n```html\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"//cdn.techpines.io/jquery.event.drag-2.0.js\"></script>\n<script src=\"/socket.io/socket.io.js\"></script>\n<script>\n    App = {}\n    App.socket = io.connect()\n\n    // Draw Function\n    App.draw = function(data) {\n        if (data.type == \"dragstart\") {\n            App.ctx.beginPath()\n            App.ctx.moveTo(data.x,data.y)\n        } else if (data.type == \"drag\") {\n            App.ctx.lineTo(data.x,data.y)\n            App.ctx.stroke()\n        } else {\n            App.ctx.stroke()\n            App.ctx.closePath()\n        }\n    }\n\n    // Draw from other sockets\n    App.socket.on('draw', App.draw) \n\n    // Bind click and drag events to drawing and sockets.\n    $(function() {\n        App.ctx = $('canvas')[0].getContext(\"2d\")\n        $('canvas').live('drag dragstart dragend', function(e) {\n            offset = $(this).offset()\n            data = {\n                x: (e.clientX - offset.left), \n                y: (e.clientY - offset.top),\n                type: e.handleObj.type\n            }\n            App.draw(data) // Draw yourself.\n            App.socket.emit('drawClick', data) // Broadcast draw.\n        })\n    })         \n</script>\n<canvas width=\"800px\" height=\"400px\" style=\"margin: 0 auto\"></canvas>\n```\n\n## Scaling with Redis\n\n__This is a copy-paste example, if redis dependencies installed.__ [(get the code)](https://github.com/techpines/express.io/tree/master/examples/scaling-with-redis)\n\nIf you need to scale your io server past one process, (which hopefully you will).  Then you need to take advantage of a pub/sub server.  Here is an example using Redis with multiple node processes.\n\nTo start, you might need to install redis, here are the [install docs](http://redis.io/topics/quickstart).\n\nOnce you have redis installed you need to install the redis node client.\n\n```\nnpm install redis\n```\n\nWhen you run this example, if you have more than one processor, then you should see a log message from the io server for each process.\n\n#### Server (app.js)\n\n```js\nexpress = require('express.io')\nredis = require('redis')\nRedisStore = express.io.RedisStore\n\n// This is what the workers will do.\nworkers = function() {\n    app = express().http().io()\n\n    // Setup the redis store for scalable io.\n    app.io.set('store', new express.io.RedisStore({\n        redisPub: redis.createClient(),\n        redisSub: redis.createClient(),\n        redisClient: redis.createClient()\n    }))\n\n    // build realtime-web app\n\n    app.listen(7076)\n}\n\n// Start forking if you are the master.\ncluster = require('cluster')\nnumCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n    for (var i = 0; i < numCPUs; i++) { cluster.fork() }\n} else { workers() }\n```\n\n## Scaling with Mongo\n\n*Coming soon!*\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1411145679815}